<!DOCTYPE html>
<html lang="en">
	<head>

		<script src="bower_components/socket.io-client/dist/socket.io.min.js"></script>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/underscore/underscore.js"></script>
		<script>WEB_SOCKET_SWF_LOCATION='bower_components/socket.io-client/dist/WebSocketMain.swf'</script>

		<title>three.js canvas - camera - orthographic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="bower_components/threejs/build/three.js"></script>

		<script src="js/threejs-stats.min.js"></script>
		<script src="js/threejs-TrackballControls.js"></script>

		<script>

			var container, stats;
			var camera, scene, renderer;

			var LOC_VLC_PID = 'WEgwAGyc9N';


			rooms = {};

			function add_room (room_name, points, x, y, z) {

				rooms[room_name] = {};

				var vectors = [];
				// Create vectors for each point
				for (i=0; i<points.length; i++) {
					vectors.push(new THREE.Vector2(-points[i][0], points[i][1]));
				}
				var room = new THREE.Shape(vectors);

				// flat shape
				var geometry = new THREE.ShapeGeometry(room);
				var material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide});

				var mesh = new THREE.Mesh(geometry, material);
				mesh.position.set(x, y, z);
				mesh.rotation.set(Math.PI/2, 0, 0);
				mesh.scale.set(1, 1, 1);
				scene.add(mesh);

				rooms[room_name]["floor"] = mesh;

				//mesh.material.color.setHex(0xFF00FF);

				// wall outline
				var geometry = room.createPointsGeometry();
				var material = new THREE.LineBasicMaterial({linewidth: 1, color: 0x333333});

				var line = new THREE.Line(geometry, material);
				line.position.set(x, y, z);
				line.rotation.set(Math.PI/2, 0, 0);
				line.scale.set(1, 1, 1);
				scene.add(line);

				rooms[room_name]["walls"] = line;

			}

			function add_point (x, y, z) {
				var geometry = new THREE.SphereGeometry(.15, 15, 6);
				var material = new THREE.MeshBasicMaterial( { color: '#ff0000'} );
				var loc      = new THREE.Mesh(geometry, material);

				loc.position.set(x,z,y);
				scene.add(loc);
			}

			function add_arrow(x1, y1, z1, x2, y2, z2) {

				var color = Math.random() * 0xffffff;

				// Draw line for the arrow
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3 (-x1, z1, y1 ));
				geometry.vertices.push(new THREE.Vector3 (-x2, z2, y2 ));
				var object = new THREE.Line(geometry, new THREE.LineBasicMaterial({linewidth: 2, color: color}));
				scene.add(object);

				// Create pyramid for arrowhead
				vertices = [[0.05,  0,      -0.0223],
				            [-0.05, 0,      -0.0223],
				            [-0,    0,      0.0577],
				            [-0,    0.0837, 0]]
				faces = [[0,1,3],
				         [1,2,3],
				         [2,0,3],
				         [2,1,0]]
				var geometry = new THREE.PolyhedronGeometry(vertices, faces, .1);
				var material = new THREE.MeshBasicMaterial({ color: color} );
				var point    = new THREE.Mesh(geometry, material);

				// Figure out the rotation for the arrowhead
				var line_vector     = new THREE.Vector3(-x2+x1, z2-z1, y2-y1).setLength(1);
				var pyramid_normal  = geometry.faces[3].normal.clone().setLength(-1);
				var rotation_axis   = new THREE.Vector3().crossVectors(line_vector, pyramid_normal).setLength(1);
				var rotation_rad    = -Math.acos(pyramid_normal.dot(line_vector));
				var rotation_matrix = new THREE.Matrix4().makeRotationAxis(rotation_axis, rotation_rad);
				point.rotation.setFromRotationMatrix(rotation_matrix);
				point.position.set(-x2, z2, y2);
				scene.add(point);

			}


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 1, 10, -15 );
				scene = new THREE.Scene();

				// Grid

		/*		var size = 25, step = 2;

				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {

					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				}

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );

				var line = new THREE.Line( geometry, material );
				line.type = THREE.LinePieces;
				scene.add( line );*/




				room4908 = [[0,      0.653],
				            [0.380,  0.653],
				            [0.380,  0],
				            [10.087, 0],
				            [10.087, 6.043],
				            [0,      6.043]];
				add_room("4908", room4908, 0,0,0)

		/*		var points4908 = [];
				points4908.push( new THREE.Vector2 ( -7.6082, 0.645 ) );
				points4908.push( new THREE.Vector2 ( -8.167,  0.645 ) );
				points4908.push( new THREE.Vector2 ( -8.167,  0.188 ) );
				points4908.push( new THREE.Vector2 ( -7.6082, 0.188 ) );
				var room4908 = new THREE.Shape( points4908 );
				addShape(room4908, 0x000000, 0,0,0,Math.PI/2,0,0,1);*/




				add_point(-5, 1,   4);
				add_point(-5, 1.1, 4);
				add_point(-8, 0.3, 2);

				add_arrow(8, 0.3, 2, 8.5, 0.4, 2);



				// Lights

				var ambientLight = new THREE.AmbientLight( Math.random() * 0x10 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				var directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );


				window.addEventListener( 'resize', onWindowResize, false );

				controls = new THREE.TrackballControls( camera );
				controls.target.set( 0, 0, 0 );



				// Setup SOCKETIO

				socket_loc = io.connect('inductor.eecs.umich.edu:8082/stream');
				socket_loc.on('connect', function (data) {
					socket_loc.emit('query', {'profile_id': LOC_VLC_PID});
				});

				socket_loc.on('data', function (data) {
					data['display_rx_time'] = Date.now();
				//	loc_hist.push(data);
					console.log(data);
				});

			}

			function onWindowResize() {

				camera.left = window.innerWidth / - 2;
				camera.right = window.innerWidth / 2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				controls.update();

				renderer.render( scene, camera );
			}


			init();
			animate();

		</script>

	</body>
</html>
